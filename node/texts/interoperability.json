{
	"SPARQL 1.0":"<p>SPARQL is the W3C standard query language for RDF. It allows to retrieve and manipulate data stored using several operators like joins, unions, optional patterns or filters.</p>",
    "SPARQL 1.1":"<p>SPARQL 1.1 is the second version of the W3C standard query language for querying RDF databases. This new version adds new operators such aggregates, new functions and the possibility to federate queries to several SPARQL endpoints.</p>",
	"Solution Modifiers":"<p><b>SPARQL 1.0 with solution modifiers:</b></p><ul><li>SEL[.]*ORDERBY*OFFSET</li><li>SEL[.]*ORDERBY-ASC</li><li>SEL[.]*ORDERBY-DESC</li><li>SEL[.]*ORDERBY</li><li>SEL-DISTINCT[.]</li><li>SEL-REDUCED[.]</li></ul>",
	"Common Operators and Filters":"<p><b>SPARQL 1.0 common operators and filters:</b></p><ul><li>SEL[.]</li><li>SEL[JOIN]</li><li>SEL[OPT]</li><li>SEL[UNION]</li><li>SEL[FIL(!BOUND)]</li><li>SEL[FIL(BLANK)]</li><li>SEL[FIL(BOOL)]</li><li>SEL[FIL(IRI)]</li><li>SEL[FIL(NUM)]</li><li>SEL[FIL(REGEX)]</li><li>SEL[FIL(REGEX-i)]</li><li>SEL[FIL(STR)]</li><li>SEL[BNODE]</li><li>SEL[EMPTY]</li></ul>",
	"Graph and other":"<p><b>SPARQL 1.0 GRAPH and other query operators:</b></p><ul><li>SEL[FROM]</li><li>SEL[GRAPH]</li><li>SEL[GRAPH;JOIN]</li><li>SEL[GRAPH;UNION]</li><li>CON[.]</li><li>CON[JOIN]</li><li>CON[OPT]</li><li>ASK[.]</li></ul>",
	"Aggregate":"<p><b>SPARQL 1.1 aggregate functions:</b></p><ul><li>SEL[AVG]*GROUPBY</li><li>SEL[AVG]</li><li>SEL[COUNT]*GROUPBY</li><li>SEL[MAX]</li><li>SEL[MIN]</li><li>SEL[MINUS]</li><li>SEL[SUM]</li></ul>",
	"Filter":"<p><b>SPARQL 1.1 filter functions:</b></p><ul><li>SEL[FIL(!EXISTS)]</li><li>SEL[FIL(ABS)]</li><li>SEL[FIL(CONTAINS)]</li><li>SEL[FIL(EXISTS)]</li><li>SEL[FIL(START)]</li></ul>",
	"Other":"<p><b>Other SPARQL 1.1 features:</b></p><ul><li>ASK[FIL(!IN)]</li><li>CON-[.]</li><li>SEL[BIND]</li><li>SEL[PATHS]</li><li>SEL[SERVICE]</li><li>SEL[SUBQ]</li><li>SEL[SUBQ;GRAPH]</li><li>SEL[VALUES]</li></ul>",
	"ask[.]": "<p><b>SPARQL simple ASK query:</b></p><p>ASK {</p><p>?s ?o owl:Thing</p><p>} </p>",
	"con[.]": "<p><b>SPARQL CONSTRUCT query with a single-triple pattern returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x rdf:type ?o }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;?x rdf:type ?o .</p><p>} LIMIT 100</p>",
	"con[join]": "<p><b>SPARQL CONSTRUCT query with two triple patterns and a join returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x rdf:type ?v }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;?x rdf:type ?o .</p><p>&nbsp;&nbsp;?o rdf:type ?x</p><p>} LIMIT 100</p>",
	"con[opt]": "<p><b>SPARQL CONSTRUCT query with two triple patterns and an optional returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x rdf:type ?v }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;?x rdf:type ?o .</p><p>&nbsp;&nbsp;OPTIONAL {?o rdf:type ?v }</p><p>} LIMIT 100</p>",
	"sel[.]*orderby*offset": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the object variable using LIMIT and OFFSET typically used for paginating results:</b></p><p>SELECT ?v</p><p>WHERE { ?s rdf:type ?v }</p><p>ORDER BY ?v</p><p>LIMIT 100</p><p>OFFSET 101</p>",
	"sel[.]*orderby-asc": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the subject variable in an ascending way:</b></p><p>SELECT *</p><p>WHERE { ?s rdf:type ?o}</p><p>ORDER BY DESC(?s) LIMIT 100</p>",
	"sel[.]*orderby-desc": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the subject variable in a descending way:</b></p><p>SELECT *</p><p>WHERE { ?s rdf:type ?o}</p><p>ORDER BY DESC(?s) LIMIT 100</p>",
	"sel[.]*orderby": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the object variable:</b></p><p>SELECT ?v</p><p>WHERE { ?s rdf:type ?v }</p><p>ORDER BY ?v</p><p>LIMIT 100</p>",
	"sel[.]": "<p><b>SPARQL SELECT query with a single-triple pattern: </b></p><p>SELECT * WHERE { ?s rdf:type ?o }  LIMIT 100</p>",
	"sel[bnode]": "<p><b>SPARQL SELECT query with a single-triple pattern querying for a random blank node:</b></p><p>select distinct * where {?c rdf:type _:bn} LIMIT 100</p>",
	"sel[empty]": "<p><b>SPARQL SELECT query with a single-triple pattern returning no results (using a non existing URI):</b></p><p>SELECT * WHERE { ?s rdf:type <http://nonsensical.com/1> }LIMIT 100</p>",
	"sel[fil(!bound)]": "<p><b>SPARQL SELECT query with a single-triple pattern filtering only blank nodes:</b></p><p>SELECT  ?a ?c</p><p>WHERE</p><p>{ ?a rdf:type ?c . </p><p>&nbsp;&nbsp;OPTIONAL { ?c rdf:type ?e } . </p><p>&nbsp;&nbsp;FILTER (! bound(?e)) </p><p>} LIMIT 100</p>",
	"sel[fil(blank)]": "<p><b>SPARQL SELECT query with a single-triple pattern filtering only blank nodes:</b></p><p>SELECT * WHERE { ?x rdf:type ?v . FILTER isBlank(?v) . } LIMIT 100</p>",
	"sel[fil(bool)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a boolean in the object position:</b></p><p>SELECT * WHERE {</p><p>?s ?o false</p><p>} LIMIT 100</p>",
	"sel[fil(iri)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering for variables being an IRI:</b></p><p>SELECT * WHERE { ?x rdf:type ?v . FILTER isIRI(?v) . } LIMIT 100</p>",
	"sel[fil(num)]": "<p><b>SPARQL SELECT query with a single-triple pattern and an integer in the object position:</b></p><p>SELECT * WHERE {</p><p>?s ?o 12</p><p>} LIMIT 100</p>",
	"sel[fil(regex)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering variables containing the \"thi\" string, case sensitive:</b></p><p>SELECT ?s ?val</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?val .</p><p>&nbsp;&nbsp;FILTER regex(?val, \"thi\")</p><p>} LIMIT 100</p>",
	"sel[fil(regex)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering variables containing the \"thi\" string, case sensitive:</b></p><p>SELECT ?s ?val</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?val .</p><p>&nbsp;&nbsp;FILTER regex(?val, \"thi\")</p><p>} LIMIT 100</p>",
	"sel[fil(regex-i)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering variables containing the \"thi\" string, ignoring case:</b></p><p>SELECT ?s ?val</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?val .</p><p>&nbsp;&nbsp;FILTER regex(?val, \"thi\", \"i\")</p><p>} LIMIT 100</p>",
	"sel[fil(str)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filering for variables containing string values:</b></p><p>SELECT ?s WHERE {</p><p>&nbsp;&nbsp;  ?s rdf:type ?v .</p><p>&nbsp;&nbsp;  FILTER(datatype(xsd:string(?v)) = xsd:string) .</p><p>} LIMIT 100</p>",
	"sel[from]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FROM NAMED clause:</b></p><p>SELECT * FROM <http://non.default.graph.com/graph1> </p><p>FROM NAMED <http://non.default.graph.com/graph2> { ?s ?p ?o } LIMIT 100</p>",
	"sel[graph]": "<p><b>SPARQL SELECT query with a GRAPH operator and a single triple pattern:</b></p><p>SELECT * { </p><p>&nbsp;&nbsp;  GRAPH ?g { ?s rdf:type ?o }</p><p>} LIMIT 100</p>",
	"sel[graph;join]": "<p><b>SPARQL SELECT query with a join of two triple patterns using GRAPH in one of the triple patterns:</b></p><p>SELECT * { </p><p>&nbsp;&nbsp;?s rdf:type ?o .</p><p>&nbsp;&nbsp;  GRAPH ?g { ?o ?p ?q }</p><p>} LIMIT 100</p>",
	"sel[graph;union]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns using GRAPH in one of the union sides:</b></p><p>SELECT * </p><p>{ </p><p>&nbsp;&nbsp; { ?s ?p ?o }</p><p>&nbsp;&nbsp;UNION</p><p>&nbsp;&nbsp; { GRAPH ?g { ?s ?p ?o } }</p><p>} LIMIT 100</p>",
	"sel[join]": "<p><b>SPARQL SELECT query with two triple patterns and a join:</b> SELECT * WHERE { ?s rdf:type ?o . ?o ?p ?o2 } LIMIT 100</p>",
	"sel[opt]": "<p><b>SPARQL SELECT query with two triple patterns and an optional:</b> SELECT * WHERE { ?s rdf:type ?o OPTIONAL {?o ?p ?x}} LIMIT 100</p>",
	"sel[union]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns:</b> SELECT * WHERE { {?s rdf:type ?o} UNION {?o rdf:type ?x}} LIMIT 100</p>",
	"sel-distinct[.]": "<p><b>SPARQL SELECT query with a single-triple pattern using DISTINCT:</b> SELECT DISTINCT * WHERE { ?s rdf:type ?o } LIMIT 100</p>",
	"sel-reduced[.]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns using REDUCED:</b></p><p>SELECT REDUCED * </p><p>WHERE { </p><p>&nbsp;&nbsp;{ ?s rdf:type ?o } UNION { ?s rdf:type owl:Thing }</p><p>} LIMIT 100</p>",
	"ask[fil(!in)]": "<p><b>SPARQL 1.1 ASK query filtering using the NOT IN operator:</b></p><p>ASK {</p><p>&nbsp;&nbsp;FILTER(2 NOT IN ())</p><p>}</p>",
	"sel[avg]*groupby": "<p><b>SPARQL 1.1 SELECT query using the average aggregate function in the SELECT clause, grouping the results:</b></p><p>PREFIX : <http://www.example.org/></p><p>PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#></p><p>SELECT ?s (AVG(?o) AS ?avg)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?o</p><p>} </p><p>GROUP BY ?s</p><p>HAVING (AVG(?o) <= 2.0)</p><p>LIMIT 100</p>",
	"sel[bind]": "<p><b>SPARQL 1.1 SELECT query using the BIND operator:</b></p><p>SELECT ?z</p><p>{</p><p>  ?s rdf:type ?o .</p><p>  BIND(?o+10 AS ?z)</p><p>} LIMIT 100</p>",
	"sel[fil(!exists)]": "<p><b>SPARQL 1.1 SELECT query filtering for non existing triple patterns (FILTER NOT EXISTS operator):</b></p><p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;?p rdf:type ?type .</p><p>&nbsp;&nbsp;FILTER NOT EXISTS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?p owl:sameAs ?same</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 100</p>",
	"sel[fil(contains)]": "<p><b>SPARQL 1.1 SELECT query using filtering results using the string CONTAINS operator:</b></p><p>SELECT ?s ?str WHERE {</p><p>&nbsp;&nbsp;?s ?p ?str</p><p>&nbsp;&nbsp;FILTER CONTAINS(?str, \"a\")</p><p>} LIMIT 100</p>",
	"sel[fil(exists)]": "<p><b>SPARQL 1.1 SELECT query filtering for existing triple patterns (FILTER EXISTS operator):</b></p><p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;?p rdf:type ?type .</p><p>&nbsp;&nbsp;FILTER EXISTS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?p owl:sameAs ?same</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 100</p>",
	"sel[fil(start)]": "<p><b>SPARQL 1.1 SELECT query filtering for the STRSTARTS string function:</b></p><p>SELECT ?s ?str WHERE {</p><p>&nbsp;&nbsp;?s ?p ?str</p><p>&nbsp;&nbsp;FILTER STRSTARTS(STR(?str), \"1\")</p><p>}</p>",
	"sel[max]": "<p><b>SPARQL 1.1 SELECT query using the MAX average function:</b></p><p>SELECT (MAX(?o) AS ?max)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?o</p><p>} LIMIT 100</p>",
	"sel[min]": "<p><b>SPARQL 1.1 SELECT query using the MIN average function:</b></p><p>SELECT ?s (MIN(?o) AS ?min)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?o</p><p>} </p><p>GROUP BY ?s</p><p>LIMIT 100</p>",
	"sel[minus]": "<p><b>SPARQL 1.1 SELECT query using the MINUS operator:</b></p><p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;?p rdf:type ?type .</p><p>&nbsp;&nbsp;MINUS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?p owl:sameAs ?same</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 100</p><p>select  ?x ?p where {</p><p>graph ?g {</p><p>{select * where {?x rdf:type ?y}}</p><p>}</p><p>} LIMIT 100</p>",
	"sel[subq;graph]": "<p><b>SPARQL 1.1 SELECT query using with a subquery and a GRAPH operator:</b></p><p>select  ?x ?p where {</p><p>graph ?g {</p><p>{select * where {?x rdf:type ?y}}</p><p>}</p><p>} LIMIT 100</p>",
	"sel[sum]": "<p><b>SPARQL 1.1 SELECT query using the SUM average function:</b></p><p>SELECT ?s (SUM(?o) AS ?sum)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s ?p ?o</p><p>} </p><p>GROUP BY ?s</p><p>LIMIT 100</p>",
	"sel[values]": "<p><b>SPARQL 1.1 SELECT query using the VALUES operator for restricting queries:</b></p><p>SELECT ?p</p><p>{</p><p>   ?p rdf:type ?o </p><p>} </p><p>VALUES ?o { owl:Thing }</p>",
	"sel[avg]": "<p><b>SPARQL 1.1 SELECT query selecting using the average aggregate function:</b></p><p>SELECT (AVG(?o) AS ?avg)</p><p>WHERE{</p><p>&nbsp;&nbsp;?s rdf:type ?o</p><p>} LIMIT 100</p>",
	"sel[count]*groupby": "<p><b>SPARQL 1.1 SELECT query selecting using the count aggregate function and grouping the results:</b></p><p>SELECT ?P (COUNT(?O) AS ?C)</p><p>WHERE { ?S ?P ?O } </p><p>GROUP BY ?P</p><p>LIMIT 100</p>",
	"sel[subq]": "<p><b>SPARQL 1.1 SELECT query with a sub select in it:</b></p><p>select ?x</p><p>where {</p><p>{select * where {?x rdf:type ?y}}</p><p>} LIMIT 100</p>",
	"sel[paths]": "<p><b>SPARQL 1.1 SELECT query containing a Property Path expression:</b></p><p>select * where {</p><p>&nbsp;&nbsp;?p rdf:type* ?z</p><p>}  LIMIT 100</p>",
	"sel[fil(abs)]": "<p><b>SPARQL 1.1 SELECT query filtering for the absolute value of an integer:</b></p><p>SELECT * WHERE {</p><p>&nbsp;&nbsp;?s rdf:type xsd:integer</p><p>&nbsp;&nbsp;FILTER(ABS(?s) >= 2)</p><p>} LIMIT 100</p>",
	"con-[.]": "<p><b>SPARQL 1.1 using the short CONSTRUCT form:</b></p><p>CONSTRUCT WHERE { ?s ?p ?o} LIMIT 100</p>",
	"sel[service]": "<p><b>SPARQL 1.1 SELECT query containing a SERVICE call to DBpedia:</b></p><p>SELECT ?s ?o1 ?o2 </p><p>{</p>  <p>&nbsp;&nbsp;?s owl:sameAs ?o1 .</p>  <p>&nbsp;&nbsp;SERVICE <http://dbpedia.org/sparql> {</p>    <p>&nbsp;&nbsp;&nbsp;&nbsp;?o1 rdf:type ?o2</p>  <p>&nbsp;&nbsp;}</p><p>} LIMIT 100</p>"
}